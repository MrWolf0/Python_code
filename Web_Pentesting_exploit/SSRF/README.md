# SSRF vulnerability

One of the most critical vulnerabilities that can affect web applications is Server-Side Request Forgery (SSRF). The danger of this vulnerability arises when an attacker can gain access to internal endpoints or services that are unavailable to the public on the internet.
The internal endpoints or services include
1- Emolpyee direcotry 
2- Internal APIS 
3- Internal authentication service 
4- LDAP or AD 
5- Database management system 
and so on
Since those services are inaccessible to the user, and they can't even see what's happening, a successful attacker making a request to one of them and getting a response could exploit that vulnerability to pivot or achieve lateral movement by chaining it with another vulnerability, such as file inclusion and Denial-of-Service (DoS). The most dangerous scenario is using phishing emails to trick an employee into installing persistent hidden malware.
SSRF attacks can be incredibly difficult to detect so what is the difference between Regular SSRF and Blind SSRF.
A Regular SSRF attack will allow an attacker to get feedback from the web app or API in the form of a response from the server, which typically includes the results of whatever unauthorized action was requested.
Blind SSRF attacks, however, are much more complex. Results from blind SSRF vulnerabilities can occur without any response from the server. This means an attacker may have little to no information on what happened on the backend so we can use burp colabrator to detect that blind SSRF and this type of testing knowen as out-of-band application security testing (OAST). 
OAST is especially useful for identifying vulnerabilities that are not easily detectable through traditional testing methods.
the most two techniques a tester use to detect blind SSRF is the content length header and the time of the response note the content header length and the time that app use to complete the request this useful when testing for the blind SSRF
This is a quick brief about the vulnerability and the next lines is the solution of portswigger labs with automation the exploit using python 

* [SSRF_Lab1.py](./SSRF_Lab1.py)

This script is used to exploit the lab. The lab is a basic example and illustrates the idea of how to test for SSRF. The idea here is that the app makes an internal request to check the stock for items, and there is an internal panel accessed by the admin. So, if I make the server send a request to that panel and get a response, that is an indicator of SSRF. I can exploit it by applying unauthorized actions such as deleting Carlos' user.
Note that the request of check stock has stockApi paramter which is an URL to internal service if we delete that paramter we get a response that has body with **"Missing parameter 'stockApi'"** so to compelete the request you need to send the request with that paramter.
Note that the request sended as url encode and it is important to encode your payload in comming labs.
then we try to send the request using **http://localhost** and we get 200 OK so the internal service intract with the payload so we can try to discover hiden internal endpoints we do that using intruder or any directory brute force tools and from the discription of the lab we know that there is an endpoint named admin 
so we try **http://localhost/admin** and from response there is an endpoint called /admin/delete?username=carlos so we need that 
sending the final request as **http://localhost/admin/delete?username=carlos** to compelete the lab.
final note is the methode of the request is post methode.


## Author :black_nib:

* __Nasser El-Din Basha my github__ <[MrWolf0](https://github.com/MrWolf0)>
* __Nasser El-Din Basha my linkedin__ <[mrwolf0](https://www.linkedin.com/in/mrwolf0)>
