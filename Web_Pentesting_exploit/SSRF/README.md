# SSRF vulnerability

One of the most critical vulnerabilities that can affect web applications is Server-Side Request Forgery (SSRF). The danger of this vulnerability arises when an attacker can gain access to internal endpoints or services that are unavailable to the public on the internet.<br>
The internal endpoints or services include<br>
1- Emolpyee direcotry <br>
2- Internal APIS <br>
3- Internal authentication service <br>
4- LDAP or AD <br>
5- Database management system <br>
and so on
Since those services are inaccessible to the user, and they can't even see what's happening, a successful attacker making a request to one of them and getting a response could exploit that vulnerability to pivot or achieve lateral movement by chaining it with another vulnerability, such as file inclusion and Denial-of-Service (DoS). The most dangerous scenario is using phishing emails to trick an employee into installing persistent hidden malware.
SSRF attacks can be incredibly difficult to detect so what is the difference between Regular SSRF and Blind SSRF.
A Regular SSRF attack will allow an attacker to get feedback from the web app or API in the form of a response from the server, which typically includes the results of whatever unauthorized action was requested.
Blind SSRF attacks, however, are much more complex. Results from blind SSRF vulnerabilities can occur without any response from the server. This means an attacker may have little to no information on what happened on the backend so we can use burp colabrator to detect that blind SSRF and this type of testing knowen as out-of-band application security testing (OAST). 
OAST is especially useful for identifying vulnerabilities that are not easily detectable through traditional testing methods.
the most two techniques a tester use to detect blind SSRF is the content length header and the time of the response note the content header length and the time that app use to complete the request this useful when testing for the blind SSRF
This is a quick brief about the vulnerability and the next lines is the solution of portswigger labs with automation the exploit using python 

* [SSRF_Lab1.py](./SSRF_Lab1.py)

**Basic SSRF against the local server**

This script is used to exploit the lab. The lab is a basic example and illustrates the idea of how to test for SSRF. The idea here is that the app makes an internal request to check the stock for items, and there is an internal panel accessed by the admin. So, if I make the server send a request to that panel and get a response, that is an indicator of SSRF. I can exploit it by applying unauthorized actions such as deleting Carlos' user.
Note that the request of check stock has stockApi paramter which is an URL to internal service if we delete that paramter we get a response that has body with **"Missing parameter 'stockApi'"** so to compelete the request you need to send the request with that paramter.
Note that the request sended as url encode and it is important to encode your payload in comming labs.
then we try to send the request using **http://localhost** and we get 200 OK so the internal service intract with the payload so we can try to discover hiden internal endpoints we do that using intruder or any directory brute force tools and from the discription of the lab we know that there is an endpoint named admin 
so we try **http://localhost/admin** and from response there is an endpoint called /admin/delete?username=carlos so we need that 
sending the final request as **http://localhost/admin/delete?username=carlos** to compelete the lab.
final note is the methode of the request is post methode.

* [SSRF_Lab2.py](./SSRF_Lab2.py)

**Basic SSRF against another back-end system**

The idea of that lab is that the admin panel is hosted on a specific IP, which is inaccessible to the normal user or to the public, but the function of checking stock is vulnerable to SSRF, so if I could make the app send a request to that panel and get a response, I could delete the user.
But you need to discover the panel's IP, and if you note the check stock function, we have **http://192.168.0.1:8080/product/stock/check?productId=1&storeId=1**
so the admin endpoint is hosted on a specific IP. We need to try intruder or in our case, we will use for loop until we get a response for the correct IP 
After that, if you note the response received from the admin endpoint, we note that there is a hyperlink to delete Carlos, so we can use check stock to delete Carlos.

* [SSRF_Lab3.py](./SSRF_Lab3.py)

**SSRF with blacklist-based input filter**

The idea is to note the status code of the response after the request refused by the server The 40x code is actually means there is a service or endpoint here but access of it is restricted to person or action performed by a trusted service or action.
and to applay that mechainism you need to deploy a blacklist or a whitelist depands on your actions.
The common blacklist elements to pervent SSRF is block any request to **localhost** or **127.0.0.1** and the endpoint check the request is comming from one of the blacklist's elements if true the request blocked or dropped.
This technique is the basic action developer do to prevent SSRF attack and we can circumvent the app to bypass this protection this the idea of the lab.
To bypass that technique, the common way is to encode version of the ip to decimal representation, octal or hexadecimal.
we can use that url 
* __Decimal representation__ <[decimal](https://www.ipaddressguide.com/ip)>
* __Octal representation__ <[octal](https://www.browserling.com/tools/ip-to-oct)>
* __Hexadecimal representation__ <[hex](https://www.browserling.com/tools/ip-to-hex)>
Also, if we try to access the admin's endpoint, the app will block the request from the information gathering. You need to bypass two things: the localhost word and the admin word and we can also try encoding once; if passed, that is good; if still blocked, try double encoding; and so on.
this is common between developers as regex filtration using blacklist of strings.
so our craft request will be the converted ip and the double encoding string.
will be like that **http://127.1/%25%36%31%25%36%34%25%36%64%25%36%39%25%36%65/delete?username=carlos**

* [SSRF_Lab4.py](./SSRF_Lab4.py)

**SSRF with whitelist-based input filter**
Before dig deeper in the lab details let's understand the url parser or how the app parse the requested url.
URL parsing refers to the process of analyzing and breaking down a URL (Uniform Resource Locator) into its individual components this is useful for a variety of reasons,
 such as:<br>
 1- Understanding how to access a resource <br>
 2- Extracting specific information <br>
 3- Manipulating URLs <br>
 This is essential for various web-related tasks, such as web scraping, network communication, and data extraction. The components of a URL typically include:<br>
1- Scheme: The protocol used to access the resource (e.g., http, https, ftp).<br>
2- Host: The domain name or IP address of the server (e.g., www.example.com).<br>
3- Port: The port number on the server (e.g., 80 for HTTP, 443 for HTTPS).<br>
4- Path: The specific resource or file within the host (e.g., /path/to/resource).<br>
5- Query: The query parameters often used in dynamic web pages (e.g., ?key1=value1&key2=value2).<br>
6- Fragment: A section within the resource, often used for navigation within the page (e.g., #section1).<br>
Consider the URL: **https://www.example.com:8080/path/to/resource?key1=value1&key2=value2#section1**
1- Scheme: https<br>
2- Host: www.example.com<br>
3- Port: 8080<br>
4- Path: /path/to/resource<br>
5- Query: key1=value1&key2=value2<br>
6- Fragment: section1<br>
note that the way that the app parse the url depends on the the backend language or may be use client side to parse the url or third-Party Libraries or even online tools.
also it is not secure to parse the url in client side using js it a risk that allow the attacker easily exploit SSRF here some example for backend lib that pasre the url: <br>
**Python use (urllib.parse) ex :**<br>
```
from urllib.parse import urlparse, parse_qs

url = 'http://username@stock.weliketoshop.net:8080/path?query=value#fragment'
parsed_url = urlparse(url)
print(parsed_url)
```

**Java use (java.net.URI and java.net.URL) ex :**
```
import java.net.URI;

URI uri = new URI("http://username@stock.weliketoshop.net:8080/path?query=value#fragment");
System.out.println(uri.getScheme());
```

**PHP use (parse_url) ex :**<br>
```
$url = 'http://username@stock.weliketoshop.net:8080/path?query=value#fragment';
$parsed_url = parse_url($url);
print_r($parsed_url);
```
<br>
**Online Tools**
For quick parsing without writing code, several online tools and websites can parse URLs and display their components.
this a quieck examplews of how backend parse the url.<br>
Let's dig deeper and understand why the app must parse the comming url .<br>
 When an application parses a URL it breaks down the URL into its individual components to understand and utilize the various parts effectively. 
 the url parser use those componants to access the resources of the app based on the coming request as following <br>
 the parser tell the app which protocol to use. For http, it would initiate an HTTP request or when using ftb it like to be access a local file system.<br>
 if the app use http authentication such this lab the parser identify it by **@** in the url.<br>
the parser identify which domain or subdomain should be accessed.<br>
the cycle of the the user's request as following:<br>
Receive the Request: When a client (e.g., a web browser) sends a request to a web server, it includes a URL specifying the resource it wants to access.<br>
Parse the URL: The server uses a URL parser to break down the incoming URL into its components (scheme, host, port, path, query, fragment, etc.).<br>
Route the Request: Based on the parsed URL, the server determines which resource or endpoint should handle the request. This often involves routing logic that matches the URL path to specific functions or controllers in the application.<br>
Authentication and Authorization: If the URL contains user information (though this is less common today), the server can use it to authenticate the request. The server may also check if the authenticated user is authorized to access the requested resource.<br>
Generate the Response: The server processes the request, interacts with necessary resources (like databases or other services), and generates an appropriate response.<br>
Send the Response: The server sends the generated response back to the client.<br>
so our lab here after try the common methods such as trying access localhost using 127.0.0.1 or any reperesentation and getting nothing we need to try every possible option to understand how the app parse the url.<br>
first we send the request with **https://127.0.0.1/** we get a response that say **"External stock check host must be stock.weliketoshop.net"**
second request as **http://stock.weliketoshop.net** getting a response with **Could not connect to external stock check service**
**the difference between two responses**
the first response<br>
 The application has a security measure in place that restricts where it can look for stock information. It only allows checks on the specific host stock.weliketoshop.net.<br>
 second response<br>
 The connection to the service could not be established for some reason.
 reasone may be Incorrect port number or other connection parameters that might prevent successful communication or DNS issue.
 so what will happen if i app still using http authentication ? <br>
 the admin send its credinationals within the request so we need test using **@** sign we send the request as **http://username@stock.weliketoshop.net** still getting the error message Could not connect to external stock check service<br>
 so what will happen if i treat the weliketoshop.net as a fragment of the url and the app still check that the request contain weliketoshop.net.
 the sending request will be **http://username#@stock.weliketoshop.net** so here we get the error message **External stock check host must be stock.weliketoshop.net** indecate thet the request initialized from external host 

## Author :black_nib:

* __Nasser El-Din Basha my github__ <[MrWolf0](https://github.com/MrWolf0)>
* __Nasser El-Din Basha my linkedin__ <[mrwolf0](https://www.linkedin.com/in/mrwolf0)>
