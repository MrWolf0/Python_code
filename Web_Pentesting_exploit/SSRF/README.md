# SSRF vulnerability

One of the most critical vulnerabilities that can affect web applications is Server-Side Request Forgery (SSRF). The danger of this vulnerability arises when an attacker can gain access to internal endpoints or services that are unavailable to the public on the internet.
The internal endpoints or services include
1- Emolpyee direcotry 
2- Internal APIS 
3- Internal authentication service 
4- LDAP or AD 
5- Database management system 
and so on
Since those services are inaccessible to the user, and they can't even see what's happening, a successful attacker making a request to one of them and getting a response could exploit that vulnerability to pivot or achieve lateral movement by chaining it with another vulnerability, such as file inclusion and Denial-of-Service (DoS). The most dangerous scenario is using phishing emails to trick an employee into installing persistent hidden malware.
SSRF attacks can be incredibly difficult to detect so what is the difference between Regular SSRF and Blind SSRF.
A Regular SSRF attack will allow an attacker to get feedback from the web app or API in the form of a response from the server, which typically includes the results of whatever unauthorized action was requested.
Blind SSRF attacks, however, are much more complex. Results from blind SSRF vulnerabilities can occur without any response from the server. This means an attacker may have little to no information on what happened on the backend so we can use burp colabrator to detect that blind SSRF and this type of testing knowen as out-of-band application security testing (OAST). 
OAST is especially useful for identifying vulnerabilities that are not easily detectable through traditional testing methods.
the most two techniques a tester use to detect blind SSRF is the content length header and the time of the response note the content header length and the time that app use to complete the request this useful when testing for the blind SSRF
This is a quick brief about the vulnerability and the next lines is the solution of portswigger labs with automation the exploit using python 

* [SSRF_Lab1.py](./SSRF_Lab1.py)

**Basic SSRF against the local server**

This script is used to exploit the lab. The lab is a basic example and illustrates the idea of how to test for SSRF. The idea here is that the app makes an internal request to check the stock for items, and there is an internal panel accessed by the admin. So, if I make the server send a request to that panel and get a response, that is an indicator of SSRF. I can exploit it by applying unauthorized actions such as deleting Carlos' user.
Note that the request of check stock has stockApi paramter which is an URL to internal service if we delete that paramter we get a response that has body with **"Missing parameter 'stockApi'"** so to compelete the request you need to send the request with that paramter.
Note that the request sended as url encode and it is important to encode your payload in comming labs.
then we try to send the request using **http://localhost** and we get 200 OK so the internal service intract with the payload so we can try to discover hiden internal endpoints we do that using intruder or any directory brute force tools and from the discription of the lab we know that there is an endpoint named admin 
so we try **http://localhost/admin** and from response there is an endpoint called /admin/delete?username=carlos so we need that 
sending the final request as **http://localhost/admin/delete?username=carlos** to compelete the lab.
final note is the methode of the request is post methode.

* [SSRF_Lab2.py](./SSRF_Lab2.py)

**Basic SSRF against another back-end system**

The idea of that lab is that the admin panel is hosted on a specific IP, which is inaccessible to the normal user or to the public, but the function of checking stock is vulnerable to SSRF, so if I could make the app send a request to that panel and get a response, I could delete the user.
But you need to discover the panel's IP, and if you note the check stock function, we have **http://192.168.0.1:8080/product/stock/check?productId=1&storeId=1**
so the admin endpoint is hosted on a specific IP. We need to try intruder or in our case, we will use for loop until we get a response for the correct IP 
After that, if you note the response received from the admin endpoint, we note that there is a hyperlink to delete Carlos, so we can use check stock to delete Carlos.

* [SSRF_Lab3.py](./SSRF_Lab2.py)

**SSRF with blacklist-based input filter**

The idea is to note the status code of the response after the request refused by the server The 40x code is actually means there is a service or endpoint here but access of it is restricted to person or action performed by a trusted service or action.
and to applay that mechainism you need to deploy a blacklist or a whitelist depands on your actions.
The common blacklist elements to pervent SSRF is block any request to **localhost** or **127.0.0.1** and the endpoint check the request is comming from one of the blacklist's elements if true the request blocked or dropped.
This technique is the basic action developer do to prevent SSRF attack and we can circumvent the app to bypass this protection this the idea of the lab.
To bypass that technique, the common way is to encode version of the ip to decimal representation, octal or hexadecimal.
we can use that url 
* __Decimal representation__ <[decimal](https://www.ipaddressguide.com/ip)>
* __Octal representation__ <[octal](https://www.browserling.com/tools/ip-to-oct)>
* __Hexadecimal representation__ <[hex](https://www.browserling.com/tools/ip-to-hex)>
Also, if we try to access the admin's endpoint, the app will block the request from the information gathering. You need to bypass two things: the localhost word and the admin word and we can also try encoding once; if passed, that is good; if still blocked, try double encoding; and so on.
this is common between developers as regex filtration using blacklist of strings.
so our craft request will be the converted ip and the double encoding string.
will be like that **http://127.1/%25%36%31%25%36%34%25%36%64%25%36%39%25%36%65/delete?username=carlos**


## Author :black_nib:

* __Nasser El-Din Basha my github__ <[MrWolf0](https://github.com/MrWolf0)>
* __Nasser El-Din Basha my linkedin__ <[mrwolf0](https://www.linkedin.com/in/mrwolf0)>
